// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: rawdata/CardLimitConf.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace fat.rawdata {

  /// <summary>Holder for reflection information generated from rawdata/CardLimitConf.proto</summary>
  public static partial class CardLimitConfReflection {

    #region Descriptor
    /// <summary>File descriptor for rawdata/CardLimitConf.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CardLimitConfReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChtyYXdkYXRhL0NhcmRMaW1pdENvbmYucHJvdG8SB3Jhd2RhdGEi4wMKCUNh",
            "cmRMaW1pdBIKCgJpZBgBIAEoBRI4CgtkYXlQYXNzSW5mbxgFIAMoCzIjLnJh",
            "d2RhdGEuQ2FyZExpbWl0LkRheVBhc3NJbmZvRW50cnkSOAoLZXJnUGFzc0lu",
            "Zm8YAiADKAsyIy5yYXdkYXRhLkNhcmRMaW1pdC5FcmdQYXNzSW5mb0VudHJ5",
            "EhIKCmlzR29sZGFibGUYBCABKAgSOAoLbWluUGFzc0luZm8YBiADKAsyIy5y",
            "YXdkYXRhLkNhcmRMaW1pdC5NaW5QYXNzSW5mb0VudHJ5EjgKC3BheVBhc3NJ",
            "bmZvGAMgAygLMiMucmF3ZGF0YS5DYXJkTGltaXQuUGF5UGFzc0luZm9FbnRy",
            "eRoyChBEYXlQYXNzSW5mb0VudHJ5EgsKA2tleRgBIAEoBRINCgV2YWx1ZRgC",
            "IAEoBToCOAEaMgoQRXJnUGFzc0luZm9FbnRyeRILCgNrZXkYASABKAUSDQoF",
            "dmFsdWUYAiABKAU6AjgBGjIKEE1pblBhc3NJbmZvRW50cnkSCwoDa2V5GAEg",
            "ASgFEg0KBXZhbHVlGAIgASgFOgI4ARoyChBQYXlQYXNzSW5mb0VudHJ5EgsK",
            "A2tleRgBIAEoBRINCgV2YWx1ZRgCIAEoBToCOAEipAEKE0NhcmRMaW1pdE1h",
            "cEFCVmFsdWUSRAoMQ2FyZExpbWl0TWFwGAEgAygLMi4ucmF3ZGF0YS5DYXJk",
            "TGltaXRNYXBBQlZhbHVlLkNhcmRMaW1pdE1hcEVudHJ5GkcKEUNhcmRMaW1p",
            "dE1hcEVudHJ5EgsKA2tleRgBIAEoBRIhCgV2YWx1ZRgCIAEoCzISLnJhd2Rh",
            "dGEuQ2FyZExpbWl0OgI4ASLZAwoNQ2FyZExpbWl0Q29uZhI+CgxDYXJkTGlt",
            "aXRNYXAYASADKAsyKC5yYXdkYXRhLkNhcmRMaW1pdENvbmYuQ2FyZExpbWl0",
            "TWFwRW50cnkSQgoOQ2FyZExpbWl0TWFwQUIYAiADKAsyKi5yYXdkYXRhLkNh",
            "cmRMaW1pdENvbmYuQ2FyZExpbWl0TWFwQUJFbnRyeRJMChNDYXJkTGltaXRN",
            "YXBBQlBhdGNoGAMgAygLMi8ucmF3ZGF0YS5DYXJkTGltaXRDb25mLkNhcmRM",
            "aW1pdE1hcEFCUGF0Y2hFbnRyeRpHChFDYXJkTGltaXRNYXBFbnRyeRILCgNr",
            "ZXkYASABKAUSIQoFdmFsdWUYAiABKAsyEi5yYXdkYXRhLkNhcmRMaW1pdDoC",
            "OAEaUwoTQ2FyZExpbWl0TWFwQUJFbnRyeRILCgNrZXkYASABKAkSKwoFdmFs",
            "dWUYAiABKAsyHC5yYXdkYXRhLkNhcmRMaW1pdE1hcEFCVmFsdWU6AjgBGlgK",
            "GENhcmRMaW1pdE1hcEFCUGF0Y2hFbnRyeRILCgNrZXkYASABKAkSKwoFdmFs",
            "dWUYAiABKAsyHC5yYXdkYXRhLkNhcmRMaW1pdE1hcEFCVmFsdWU6AjgBQj1a",
            "LWdpdGxhYi5mdW5wbHVzLmlvL2ZhdC9jb25mL2dlbi9nb2xhbmcvcmF3ZGF0",
            "YaoCC2ZhdC5yYXdkYXRhYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::fat.rawdata.CardLimit), global::fat.rawdata.CardLimit.Parser, new[]{ "Id", "DayPassInfo", "ErgPassInfo", "IsGoldable", "MinPassInfo", "PayPassInfo" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::fat.rawdata.CardLimitMapABValue), global::fat.rawdata.CardLimitMapABValue.Parser, new[]{ "CardLimitMap" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::fat.rawdata.CardLimitConf), global::fat.rawdata.CardLimitConf.Parser, new[]{ "CardLimitMap", "CardLimitMapAB", "CardLimitMapABPatch" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, })
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// annotation@annotation_type(type="rawdata")
  /// annotation@rawdata(row="CardLimit",table="CardLimitMap",table_wrapper="CardLimitConf",map="true",map_key_type="int32",data="CardLimitConf")
  /// annotation@ab(table_ab="CardLimitMapAB",table_ab_patch="CardLimitMapABPatch",table_ab_value="CardLimitMapABValue",ab_patch="false")
  /// annotation@filter(just_server="false",just_client="false")
  /// annotation@CardLimit(id="id")
  /// </summary>
  public sealed partial class CardLimit : pb::IMessage<CardLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CardLimit> _parser = new pb::MessageParser<CardLimit>(() => new CardLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CardLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::fat.rawdata.CardLimitConfReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimit(CardLimit other) : this() {
      id_ = other.id_;
      dayPassInfo_ = other.dayPassInfo_.Clone();
      ergPassInfo_ = other.ergPassInfo_.Clone();
      isGoldable_ = other.isGoldable_;
      minPassInfo_ = other.minPassInfo_.Clone();
      payPassInfo_ = other.payPassInfo_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimit Clone() {
      return new CardLimit(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private int id_;
    /// <summary>
    /// 限制条件ID
    /// annotation@field_id(id="true")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "dayPassInfo" field.</summary>
    public const int DayPassInfoFieldNumber = 5;
    private static readonly pbc::MapField<int, int>.Codec _map_dayPassInfo_codec
        = new pbc::MapField<int, int>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForInt32(16, 0), 42);
    private readonly pbc::MapField<int, int> dayPassInfo_ = new pbc::MapField<int, int>();
    /// <summary>
    /// 活动天数限制条件
    /// （结合本期活动实际的tempId使用）
    /// {tempId:ergPass}
    /// -1代表无论天数是多少，都无法满足条件
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, int> DayPassInfo {
      get { return dayPassInfo_; }
    }

    /// <summary>Field number for the "ergPassInfo" field.</summary>
    public const int ErgPassInfoFieldNumber = 2;
    private static readonly pbc::MapField<int, int>.Codec _map_ergPassInfo_codec
        = new pbc::MapField<int, int>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForInt32(16, 0), 18);
    private readonly pbc::MapField<int, int> ergPassInfo_ = new pbc::MapField<int, int>();
    /// <summary>
    /// 能量限制条件
    /// （结合本期活动实际的tempId使用）
    /// {tempId:ergPass}
    /// -1代表无论能量是多少，都无法满足条件
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, int> ErgPassInfo {
      get { return ergPassInfo_; }
    }

    /// <summary>Field number for the "isGoldable" field.</summary>
    public const int IsGoldableFieldNumber = 4;
    private bool isGoldable_;
    /// <summary>
    /// 是否可以
    /// 被ObjCardPack.goldPayPass加成
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGoldable {
      get { return isGoldable_; }
      set {
        isGoldable_ = value;
      }
    }

    /// <summary>Field number for the "minPassInfo" field.</summary>
    public const int MinPassInfoFieldNumber = 6;
    private static readonly pbc::MapField<int, int>.Codec _map_minPassInfo_codec
        = new pbc::MapField<int, int>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForInt32(16, 0), 50);
    private readonly pbc::MapField<int, int> minPassInfo_ = new pbc::MapField<int, int>();
    /// <summary>
    /// 最低能量限制条件
    /// （结合本期活动实际的tempId使用）
    /// {tempId:ergPass}
    /// -1代表无论能量是多少，都无法满足条件
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, int> MinPassInfo {
      get { return minPassInfo_; }
    }

    /// <summary>Field number for the "payPassInfo" field.</summary>
    public const int PayPassInfoFieldNumber = 3;
    private static readonly pbc::MapField<int, int>.Codec _map_payPassInfo_codec
        = new pbc::MapField<int, int>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForInt32(16, 0), 26);
    private readonly pbc::MapField<int, int> payPassInfo_ = new pbc::MapField<int, int>();
    /// <summary>
    /// 充值限制条件
    /// （结合本期活动实际的tempId使用）
    /// {tempId:payPass}
    /// （payPass为美分）
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, int> PayPassInfo {
      get { return payPassInfo_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CardLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CardLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!DayPassInfo.Equals(other.DayPassInfo)) return false;
      if (!ErgPassInfo.Equals(other.ErgPassInfo)) return false;
      if (IsGoldable != other.IsGoldable) return false;
      if (!MinPassInfo.Equals(other.MinPassInfo)) return false;
      if (!PayPassInfo.Equals(other.PayPassInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0) hash ^= Id.GetHashCode();
      hash ^= DayPassInfo.GetHashCode();
      hash ^= ErgPassInfo.GetHashCode();
      if (IsGoldable != false) hash ^= IsGoldable.GetHashCode();
      hash ^= MinPassInfo.GetHashCode();
      hash ^= PayPassInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Id);
      }
      ergPassInfo_.WriteTo(output, _map_ergPassInfo_codec);
      payPassInfo_.WriteTo(output, _map_payPassInfo_codec);
      if (IsGoldable != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsGoldable);
      }
      dayPassInfo_.WriteTo(output, _map_dayPassInfo_codec);
      minPassInfo_.WriteTo(output, _map_minPassInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Id);
      }
      ergPassInfo_.WriteTo(ref output, _map_ergPassInfo_codec);
      payPassInfo_.WriteTo(ref output, _map_payPassInfo_codec);
      if (IsGoldable != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsGoldable);
      }
      dayPassInfo_.WriteTo(ref output, _map_dayPassInfo_codec);
      minPassInfo_.WriteTo(ref output, _map_minPassInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Id);
      }
      size += dayPassInfo_.CalculateSize(_map_dayPassInfo_codec);
      size += ergPassInfo_.CalculateSize(_map_ergPassInfo_codec);
      if (IsGoldable != false) {
        size += 1 + 1;
      }
      size += minPassInfo_.CalculateSize(_map_minPassInfo_codec);
      size += payPassInfo_.CalculateSize(_map_payPassInfo_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CardLimit other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0) {
        Id = other.Id;
      }
      dayPassInfo_.Add(other.dayPassInfo_);
      ergPassInfo_.Add(other.ergPassInfo_);
      if (other.IsGoldable != false) {
        IsGoldable = other.IsGoldable;
      }
      minPassInfo_.Add(other.minPassInfo_);
      payPassInfo_.Add(other.payPassInfo_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadInt32();
            break;
          }
          case 18: {
            ergPassInfo_.AddEntriesFrom(input, _map_ergPassInfo_codec);
            break;
          }
          case 26: {
            payPassInfo_.AddEntriesFrom(input, _map_payPassInfo_codec);
            break;
          }
          case 32: {
            IsGoldable = input.ReadBool();
            break;
          }
          case 42: {
            dayPassInfo_.AddEntriesFrom(input, _map_dayPassInfo_codec);
            break;
          }
          case 50: {
            minPassInfo_.AddEntriesFrom(input, _map_minPassInfo_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadInt32();
            break;
          }
          case 18: {
            ergPassInfo_.AddEntriesFrom(ref input, _map_ergPassInfo_codec);
            break;
          }
          case 26: {
            payPassInfo_.AddEntriesFrom(ref input, _map_payPassInfo_codec);
            break;
          }
          case 32: {
            IsGoldable = input.ReadBool();
            break;
          }
          case 42: {
            dayPassInfo_.AddEntriesFrom(ref input, _map_dayPassInfo_codec);
            break;
          }
          case 50: {
            minPassInfo_.AddEntriesFrom(ref input, _map_minPassInfo_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CardLimitMapABValue : pb::IMessage<CardLimitMapABValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CardLimitMapABValue> _parser = new pb::MessageParser<CardLimitMapABValue>(() => new CardLimitMapABValue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CardLimitMapABValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::fat.rawdata.CardLimitConfReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitMapABValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitMapABValue(CardLimitMapABValue other) : this() {
      cardLimitMap_ = other.cardLimitMap_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitMapABValue Clone() {
      return new CardLimitMapABValue(this);
    }

    /// <summary>Field number for the "CardLimitMap" field.</summary>
    public const int CardLimitMapFieldNumber = 1;
    private static readonly pbc::MapField<int, global::fat.rawdata.CardLimit>.Codec _map_cardLimitMap_codec
        = new pbc::MapField<int, global::fat.rawdata.CardLimit>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForMessage(18, global::fat.rawdata.CardLimit.Parser), 10);
    private readonly pbc::MapField<int, global::fat.rawdata.CardLimit> cardLimitMap_ = new pbc::MapField<int, global::fat.rawdata.CardLimit>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, global::fat.rawdata.CardLimit> CardLimitMap {
      get { return cardLimitMap_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CardLimitMapABValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CardLimitMapABValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!CardLimitMap.Equals(other.CardLimitMap)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= CardLimitMap.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      cardLimitMap_.WriteTo(output, _map_cardLimitMap_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      cardLimitMap_.WriteTo(ref output, _map_cardLimitMap_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += cardLimitMap_.CalculateSize(_map_cardLimitMap_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CardLimitMapABValue other) {
      if (other == null) {
        return;
      }
      cardLimitMap_.Add(other.cardLimitMap_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            cardLimitMap_.AddEntriesFrom(input, _map_cardLimitMap_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            cardLimitMap_.AddEntriesFrom(ref input, _map_cardLimitMap_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CardLimitConf : pb::IMessage<CardLimitConf>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CardLimitConf> _parser = new pb::MessageParser<CardLimitConf>(() => new CardLimitConf());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CardLimitConf> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::fat.rawdata.CardLimitConfReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitConf() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitConf(CardLimitConf other) : this() {
      cardLimitMap_ = other.cardLimitMap_.Clone();
      cardLimitMapAB_ = other.cardLimitMapAB_.Clone();
      cardLimitMapABPatch_ = other.cardLimitMapABPatch_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CardLimitConf Clone() {
      return new CardLimitConf(this);
    }

    /// <summary>Field number for the "CardLimitMap" field.</summary>
    public const int CardLimitMapFieldNumber = 1;
    private static readonly pbc::MapField<int, global::fat.rawdata.CardLimit>.Codec _map_cardLimitMap_codec
        = new pbc::MapField<int, global::fat.rawdata.CardLimit>.Codec(pb::FieldCodec.ForInt32(8, 0), pb::FieldCodec.ForMessage(18, global::fat.rawdata.CardLimit.Parser), 10);
    private readonly pbc::MapField<int, global::fat.rawdata.CardLimit> cardLimitMap_ = new pbc::MapField<int, global::fat.rawdata.CardLimit>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, global::fat.rawdata.CardLimit> CardLimitMap {
      get { return cardLimitMap_; }
    }

    /// <summary>Field number for the "CardLimitMapAB" field.</summary>
    public const int CardLimitMapABFieldNumber = 2;
    private static readonly pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>.Codec _map_cardLimitMapAB_codec
        = new pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::fat.rawdata.CardLimitMapABValue.Parser), 18);
    private readonly pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue> cardLimitMapAB_ = new pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue> CardLimitMapAB {
      get { return cardLimitMapAB_; }
    }

    /// <summary>Field number for the "CardLimitMapABPatch" field.</summary>
    public const int CardLimitMapABPatchFieldNumber = 3;
    private static readonly pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>.Codec _map_cardLimitMapABPatch_codec
        = new pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::fat.rawdata.CardLimitMapABValue.Parser), 26);
    private readonly pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue> cardLimitMapABPatch_ = new pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::fat.rawdata.CardLimitMapABValue> CardLimitMapABPatch {
      get { return cardLimitMapABPatch_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CardLimitConf);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CardLimitConf other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!CardLimitMap.Equals(other.CardLimitMap)) return false;
      if (!CardLimitMapAB.Equals(other.CardLimitMapAB)) return false;
      if (!CardLimitMapABPatch.Equals(other.CardLimitMapABPatch)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= CardLimitMap.GetHashCode();
      hash ^= CardLimitMapAB.GetHashCode();
      hash ^= CardLimitMapABPatch.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      cardLimitMap_.WriteTo(output, _map_cardLimitMap_codec);
      cardLimitMapAB_.WriteTo(output, _map_cardLimitMapAB_codec);
      cardLimitMapABPatch_.WriteTo(output, _map_cardLimitMapABPatch_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      cardLimitMap_.WriteTo(ref output, _map_cardLimitMap_codec);
      cardLimitMapAB_.WriteTo(ref output, _map_cardLimitMapAB_codec);
      cardLimitMapABPatch_.WriteTo(ref output, _map_cardLimitMapABPatch_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += cardLimitMap_.CalculateSize(_map_cardLimitMap_codec);
      size += cardLimitMapAB_.CalculateSize(_map_cardLimitMapAB_codec);
      size += cardLimitMapABPatch_.CalculateSize(_map_cardLimitMapABPatch_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CardLimitConf other) {
      if (other == null) {
        return;
      }
      cardLimitMap_.Add(other.cardLimitMap_);
      cardLimitMapAB_.Add(other.cardLimitMapAB_);
      cardLimitMapABPatch_.Add(other.cardLimitMapABPatch_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            cardLimitMap_.AddEntriesFrom(input, _map_cardLimitMap_codec);
            break;
          }
          case 18: {
            cardLimitMapAB_.AddEntriesFrom(input, _map_cardLimitMapAB_codec);
            break;
          }
          case 26: {
            cardLimitMapABPatch_.AddEntriesFrom(input, _map_cardLimitMapABPatch_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            cardLimitMap_.AddEntriesFrom(ref input, _map_cardLimitMap_codec);
            break;
          }
          case 18: {
            cardLimitMapAB_.AddEntriesFrom(ref input, _map_cardLimitMapAB_codec);
            break;
          }
          case 26: {
            cardLimitMapABPatch_.AddEntriesFrom(ref input, _map_cardLimitMapABPatch_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
