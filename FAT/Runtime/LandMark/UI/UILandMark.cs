/**
 * @Author: generated by assistant
 * @Date: 2025/08/08
 * @Description: LandMark 主界面（参考 UIPackDiscount）
 */

using System.Collections;
using System.Collections.Generic;
using Config;
using EL;
using FAT.MSG;
using Spine;
using Spine.Unity;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using DG.Tweening;
using Animation = UnityEngine.Animation;
using fat.rawdata;

namespace FAT
{
    public class UILandMark : UIBase, INavBack
    {
        [SerializeField] TMP_Text cdText;
        [SerializeField] TMP_Text subtitleText;
        [SerializeField] Transform path;
        [SerializeField] List<Transform> mark;
        [SerializeField] Transform final;
        [SerializeField] Transform subReward;
        [SerializeField] GameObject collectBtnGameObject;
        [SerializeField] Animation goBtnAnim;
        [SerializeField] Transform tipsFromPoint;
        private GameObject _closeBtnGo;
        PathItem pathItem;
        List<MarkItem> markItems = new();
        SubRewardItem subRewardItem;
        FinalItem finalItem;
        LandMarkActivity activity;
        private class PathItem
        {
            SkeletonGraphic spine;
            int lastStaticProgress = -1; // 已静态展示到的进度（token 个数）
            public PathItem(Transform trans)
            {
                spine = trans.Access<SkeletonGraphic>("ProgressBarSpine");
            }
            // 将进度直接静态设置到目标（不播放过渡）
            public void SetStaticProgress(int progress)
            {
                lastStaticProgress = Mathf.Max(0, progress);
                if (progress <= 0)
                {
                    // 0 段：使用静态态 "1"
                    spine.AnimationState.SetAnimation(0, "1", false);
                }
                else
                {
                    // 非 0 段：使用 "XtoY" 动画并直接跳到结束帧
                    int fromState = progress;
                    int toState = progress + 1;
                    string animName = $"{fromState}to{toState}";
                    var entry = spine.AnimationState.SetAnimation(0, animName, false);
                    entry.TrackTime = entry.AnimationEnd; // 直接静态到动画结束状态
                }
            }
            // 从 from 到 to 连续播放分段动画（如 0->2：播放 "1to2"、"2to3"），每段开始前延迟 1.1s，再播放并等待该段完成
            public void PlayProgress(MonoBehaviour runner, int from, int to, System.Action<int> onStepStart = null, System.Action<int> onStepComplete = null, System.Action onAllComplete = null)
            {
                if (runner == null)
                {
                    return;
                }
                runner.StartCoroutine(CoPlayProgress(from, to, onStepStart, onStepComplete, onAllComplete));
            }

            private IEnumerator CoPlayProgress(int from, int to, System.Action<int> onStepStart, System.Action<int> onStepComplete, System.Action onAllComplete)
            {
                from = Mathf.Max(0, from);
                to = Mathf.Max(0, to);
                if (to <= from)
                {
                    SetStaticProgress(to);
                    onAllComplete?.Invoke();
                    yield break;
                }

                // 若当前静态显示落后于 from，先对齐
                if (lastStaticProgress != from)
                {
                    SetStaticProgress(from);
                }

                int current = from;
                while (current < to)
                {
                    onStepStart?.Invoke(current);
                    // 每段播放前延迟
                    yield return new WaitForSeconds(1.1f);

                    int fromState = current + 1;
                    int toState = current + 2;
                    string animName = $"{fromState}to{toState}";
                    bool done = false;
                    var entry = spine.AnimationState.SetAnimation(0, animName, false);
                    entry.Complete += (trackEntry) => { done = true; };
                    while (!done)
                    {
                        yield return null;
                    }
                    current += 1;
                    onStepComplete?.Invoke(current);
                }

                SetStaticProgress(to);
                onAllComplete?.Invoke();
            }
        }
        private class MarkItem
        {
            public enum State
            {
                WaitFinish,
                Finish,
            }
            Animation animaton;
            GameObject iconObj;
            GameObject iconGrayObj;
            GameObject collectObj;
            GameObject lockObj;
            UIStateGroup stateGroup;
            GameObject effectObj;
            public GameObject backEffectObj;
            public MarkItem(Transform trans)
            {
                animaton = trans.Access<Animation>();
                iconObj = trans.Access<Transform>("Icon").gameObject;
                iconGrayObj = trans.Access<Transform>("Icon_gray").gameObject;
                collectObj = trans.Access<Transform>("Collect").gameObject;
                lockObj = trans.Access<Transform>("Lock").gameObject;
                stateGroup = trans.Access<UIStateGroup>();
                effectObj = trans.Access<Transform>("Effect_Item").gameObject;
                backEffectObj = trans.Access<Transform>("fx_common_icon_glow02").gameObject;
            }
            public void SetGolden(bool isGolden)
            {
                stateGroup.Select(isGolden ? 1 : 0);
            }
            public void SetState(State state)
            {
                effectObj.SetActive(false);
                switch (state)
                {
                    case State.WaitFinish:
                        iconObj.SetActive(false);
                        iconGrayObj.SetActive(true);
                        collectObj.SetActive(false);
                        break;
                    case State.Finish:
                        iconObj.SetActive(true);
                        iconGrayObj.SetActive(false);
                        collectObj.SetActive(true);
                        break;
                }
            }
            public void SetLock(bool isLock)
            {
                lockObj.SetActive(isLock);
            }
            public void SetBackEffect(bool isActive)
            {
                backEffectObj.SetActive(isActive);
            }
            private void PrepareAnim()
            {
                iconObj.SetActive(true);
                iconGrayObj.SetActive(true);
                collectObj.SetActive(true);
                lockObj.SetActive(false);
                backEffectObj.SetActive(false);
            }
            public void PlayPunch()
            {
                PrepareAnim();
                backEffectObj.SetActive(true);
                animaton.Play("LandMarkItem_Punch");
            }
            public void PlayChange()
            {
                PrepareAnim();
                animaton.Play("LandMarkItem_Change");
            }
        }
        private class FinalItem
        {
            Transform chest;
            Animator animator;
            Coroutine _punchCo;
            public FinalItem(Transform trans)
            {
                chest = trans.Find("journey_chest");
                animator = trans.Access<Animator>();
            }
            public void PlayIdle()
            {
                animator.Play("LandMarkFinalItem_Idle");
            }
            public void PlayPunch(MonoBehaviour runner)
            {
                animator.Play("LandMarkFinalItem_Punch");
                if (runner == null)
                {
                    return;
                }
                if (_punchCo != null)
                {
                    runner.StopCoroutine(_punchCo);
                    _punchCo = null;
                }
                float duration = 1.2f;
                _punchCo = runner.StartCoroutine(CoPlayPunch(duration));
            }
            public void PlayIdleWin()
            {
                animator.Play("LandMarkFinalItem_IdleWin");
            }
            public Vector3 GetChestPos()
            {
                return chest.position;
            }

            private IEnumerator CoPlayPunch(float delay)
            {
                yield return new WaitForSeconds(delay);
                PlayIdleWin();
                _punchCo = null;
            }
        }
        private class SubRewardItem
        {
            Animation animaton;
            UICommonItem item;
            GameObject collectObj;
            public SubRewardItem(Transform trans)
            {
                animaton = trans.Access<Animation>("Collect");
                item = trans.Find("UICommonItem").Access<UICommonItem>();
                collectObj = trans.Find("Collect").gameObject;
            }
            public void SetState(bool isCollected)
            {
                collectObj.SetActive(isCollected);
            }
            public void OnPreOpen(RewardConfig config)
            {
                item.Refresh(config);
            }
            public void OnCollect(RewardCommitData commitData)
            {
                collectObj.SetActive(true);
                animaton.Play("LandMarkSubRewardCollect_Show");
                if (commitData != null)
                {
                    UIFlyUtility.FlyReward(commitData, item.transform.position);
                }
            }
        }
        protected override void OnCreate()
        {
            base.OnCreate();
            final.AddButton("FinalBtn", OnClickFinal);
            transform.AddButton("Content/go", OnClickGo);
            transform.AddButton("Content/CollectBtn", OnClickCollect);
            transform.AddButton("Content/close", Close);
            transform.AddButton("Mask", OnClickMask);
            var closeT = transform.Find("Content/close");
            _closeBtnGo = closeT != null ? closeT.gameObject : null;
            pathItem = new PathItem(path);
            finalItem = new FinalItem(final);
            subRewardItem = new SubRewardItem(subReward);
            foreach (var item in mark)
            {
                markItems.Add(new MarkItem(item));
            }
        }
        protected override void OnParse(params object[] items)
        {
            base.OnParse(items);
            activity = (LandMarkActivity)items[0];
        }
        protected override void OnPreOpen()
        {
            base.OnPreOpen();
            collectBtnGameObject.SetActive(false);
            subRewardItem.OnPreOpen(activity.GetSmallRewardConfig());
            finalItem.PlayIdle();

            // 弹出时：若本次可领大奖，隐藏关闭按钮
            if (_closeBtnGo != null)
            {
                bool canClaimBig = activity.GetBigRewardCommitData() != null;
                _closeBtnGo.SetActive(!canClaimBig);
            }

            // 仅刷新初始静态状态（不播放动画）
            RefreshByProgress(activity.ShowedTokenCount_View, activity.TokenCount_View);
            RefreshSubtitle(activity.ShowedTokenCount_View);
            goBtnAnim.gameObject.SetActive(activity.ShowedTokenCount_View == activity.TokenCount_View);
            RefreshCd();
        }
        protected override void OnPostOpen()
        {
            base.OnPostOpen();
            // 打开后再开始播放进度动画
            PlayProgressRange(activity.ShowedTokenCount_View, activity.TokenCount_View);
            activity.OnMainUIPop();
        }
        protected override void OnAddListener()
        {
            base.OnAddListener();
            MessageCenter.Get<ACTIVITY_END>().AddListener(OnActivityEnd);
            MessageCenter.Get<GAME_ONE_SECOND_DRIVER>().AddListener(RefreshCd);
        }
        protected override void OnRemoveListener()
        {
            base.OnRemoveListener();
            MessageCenter.Get<ACTIVITY_END>().RemoveListener(OnActivityEnd);
            MessageCenter.Get<GAME_ONE_SECOND_DRIVER>().RemoveListener(RefreshCd);
        }
        private void OnActivityEnd(ActivityLike act, bool expire)
        {
            if (act is LandMarkActivity)
            {
                TryCollectReward();
                Close();
            }
        }
        private void RefreshCd()
        {
            if (activity == null || cdText == null) return;
            var t = Game.Instance.GetTimestampSeconds();
            var diff = (long)Mathf.Max(0, activity.endTS - t);
            UIUtility.CountDownFormat(cdText, diff);
            if (diff <= 1)
            {
                TryCollectReward();
                Close();
            }
        }
        private void RefreshSubtitle(int progress)
        {
            if (subtitleText == null) return;
            int goldenStart = activity.GetGoldenStartIndex();
            int totalSteps = markItems.Count;
            string key = progress < goldenStart ? "#SysComDesc1527" : (progress < totalSteps ? "#SysComDesc1528" : "#SysComDesc1529");

            // 使用 ObjBasic 读取图标和名称
            var tokenConfig = Game.Manager.objectMan.GetTokenConfig(activity.GetTokenId());
            string spriteName = tokenConfig.SpriteName;
            // 图文混排：优先展示图标+空格+名称；若无图标，仅展示名称
            string tokenRich = $"<sprite name=\"{spriteName}\">";

            // 文案占位：{0} → token 富文本
            subtitleText.text = I18N.FormatText(key, tokenRich);
        }
        // 统一的播放进度入口：根据 from→to 决定是否播放动画（静态刷新已在 OnPreOpen 完成）
        private void PlayProgressRange(int from, int to)
        {
            from = Mathf.Clamp(from, 0, markItems.Count);
            to = Mathf.Clamp(to, 0, markItems.Count);

            if (from >= to) { return; }

            // 此处不再做静态刷新，已在 OnPreOpen 完成
            LockEvent();
            pathItem.PlayProgress(this, from, to,
                // onStepStart
                (current) =>
                {
                    if (current >= 0 && current < markItems.Count)
                    {
                        markItems[current].PlayChange();
                    }
                },
                // onStepComplete
                (stepDone) =>
                {
                    int idx = stepDone - 1;
                    if (idx >= 0 && idx < markItems.Count)
                    {
                        // 当前步完成 → 标记为 Finish
                        // 下一步等待完成态
                        int next = idx + 1;
                        if (next >= 0 && next < markItems.Count)
                        {
                            markItems[next].PlayPunch();
                        }
                    }
                    if (stepDone == activity.GetSmallRewardStep())
                    {
                        subRewardItem.OnCollect(activity.GetSmallRewardCommitData());
                        activity.OnCollectedSmallReward();
                    }
                    RefreshSubtitle(stepDone);
                },
                () =>
                {
                    if (activity.CollectedFinal)
                    {
                        finalItem.PlayPunch(this);
                        collectBtnGameObject.SetActive(true);
                    }
                    else
                    {
                        goBtnAnim.gameObject.SetActive(true);
                        goBtnAnim.Play("UILandMarkCollectBtn_Show");
                    }
                    UnlockEvent();
                }
            );
        }
        // 刷新界面为指定进度（无动画）：
        // progress=n 表示已经完成了 n 步，0<=n<=5；
        // - 节点：i<n → Finish；i==n → WaitFinish；i>n → Lock；
        // - 进度条：显示 (n+1) 的静态/结束态；当 n==5 时显示 6 的静态态
        private void RefreshByProgress(int progress, int total)
        {
            // 子奖励显示状态
            subRewardItem.SetState(progress >= activity.GetSmallRewardStep());

            // 刷新每个节点锁定/解锁与金色态
            for (int i = 0; i < markItems.Count; i++)
            {
                var state = i < progress ? MarkItem.State.Finish : MarkItem.State.WaitFinish;
                markItems[i].SetState(state);
                markItems[i].SetGolden(i >= activity.GetGoldenStartIndex());
                if (state == MarkItem.State.WaitFinish)
                {
                    markItems[i].SetLock(i > total);
                }
                else
                {
                    markItems[i].SetLock(false);
                }
                markItems[i].SetBackEffect(i == total && progress == total);
            }

            // 刷新进度条静态显示：内部以 progress 映射到 (progress+1) 的显示
            // 进度最大为 5，则展示到 6 的静态态
            pathItem.SetStaticProgress(Mathf.Clamp(progress, 0, 5));
        }
        private void OnClickFinal()
        {
            Game.Manager.randomBoxMan.TryOpenRandomBoxTips(activity.GetBigRewardConfigId(), tipsFromPoint.position, 0f);
        }
        private void OnClickCollect()
        {
            TryCollectReward();
            Close();
        }
        private void OnClickMask()
        {
            if (_closeBtnGo.activeSelf)
            {
                TryCollectReward();
                Close();
            }
        }
        private void TryCollectReward()
        {
            if (activity == null)
                return;
            if (activity.GetSmallRewardCommitData() != null)
            {
                subRewardItem.OnCollect(activity.GetSmallRewardCommitData());
                activity.OnCollectedSmallReward();
            }
            if (activity.GetBigRewardCommitData() != null)
            {
                UIFlyUtility.FlyReward(activity.GetBigRewardCommitData(), finalItem.GetChestPos(),
                () =>
                {
                    activity.OnCollectedBigReward();
                });
            }
        }
        private void OnClickGo()
        {
            TryCollectReward();
            Close();
            var de = Game.Manager.dailyEvent;
            if (de != null)
            {
                de.OpenTask();
            }
        }
        public void OnNavBack()
        {
            if (IsLocked())
            {
                return;
            }
            TryCollectReward();
            Close();
        }
    }
}
